<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neuro-Motor Hub Mobile</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <style>
        body { margin: 0; background: #000; color: #00ff00; font-family: 'Courier New', monospace; overflow: hidden; touch-action: none; }
        #container { position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; }
        video { display: none; }
        #ui-top { position: absolute; top: 20px; width: 100%; text-align: center; z-index: 10; font-weight: bold; font-size: 14px; text-shadow: 2px 2px #000; }
        .overlay-txt { position: absolute; width: 80%; left: 10%; text-align: center; z-index: 10; background: rgba(0,0,0,0.7); border: 1px solid #0f0; padding: 10px; }
    </style>
</head>
<body>

<div id="container">
    <video id="input_video" playsinline></video>
    <canvas id="gameCanvas"></canvas>
    <div id="ui-top">NEURO-LINK STATUS: <span id="status">INIT</span></div>
</div>

<script>
/** * --- CONFIG & ENGINE ---
 */
const videoElement = document.getElementById('input_video');
const canvasElement = document.getElementById('gameCanvas');
const ctx = canvasElement.getContext('2d');
const statusEl = document.getElementById('status');

let gameState = "BOOT"; // BOOT, CALIBRATE, PLAYING, GAMEOVER
let score = 0, lives = 3, bootTimer = 0, romProgress = 0;
let handX = 0, handY = 0, pinching = false, eyeClosed = false;
let enemies = [], bullets = [], tremorData = [], reactionTimes = [];
let lastShotTime = 0, spawnCounter = 0;

function resize() {
    canvasElement.width = window.innerWidth;
    canvasElement.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Audio Setup
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSfx(freqStart, freqEnd, duration) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.frequency.setValueAtTime(freqStart, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(freqEnd, audioCtx.currentTime + duration);
    osc.connect(gain); gain.connect(audioCtx.destination);
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration);
    osc.start(); osc.stop(audioCtx.currentTime + duration);
}

/** * --- MEDIAPIPE AI MODELS ---
 */
const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });

const faceMesh = new FaceMesh({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` });
faceMesh.setOptions({ refineLandmarks: true, minDetectionConfidence: 0.6 });

// Hand Processing Logic
hands.onResults((results) => {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        statusEl.innerText = "HAND LOCKED";
        const lm = results.multiHandLandmarks[0];
        const targetX = (1 - lm[8].x) * canvasElement.width;
        const targetY = lm[8].y * canvasElement.height;

        // Smoothing
        handX += (targetX - handX) * 0.4;
        handY += (targetY - handY) * 0.4;

        // Pinch Calculation (8 = Index Tip, 4 = Thumb Tip)
        const dist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
        pinching = dist < 0.06;

        if (gameState === "PLAYING") {
            tremorData.push(Math.abs(targetX - handX) + Math.abs(targetY - handY));
            if (tremorData.length > 60) tremorData.shift();
        }
    } else { statusEl.innerText = "SEARCHING..."; }
});

// Face Processing Logic (Blink Detection)
faceMesh.onResults((results) => {
    if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
        const lm = results.multiFaceLandmarks[0];
        // Simplified Eye Aspect Ratio
        const top = lm[159], bottom = lm[145];
        const eyeDist = Math.hypot(top.x - bottom.x, top.y - bottom.y);
        eyeClosed = eyeDist < 0.012;
    }
});

const camera = new Camera(videoElement, {
    onFrame: async () => {
        await hands.send({image: videoElement});
        if (gameState === "BOOT" || gameState === "CALIBRATE") await faceMesh.send({image: videoElement});
    },
    width: 480, height: 640
});
camera.start();

/** * --- MAIN GAME ENGINE ---
 */
function drawLoop() {
    ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);

    // Scanline Effect
    ctx.fillStyle = "rgba(0, 255, 0, 0.05)";
    ctx.fillRect(0, (Date.now() / 5) % canvasElement.height, canvasElement.width, 2);

    if (gameState === "BOOT") {
        bootTimer++;
        ctx.fillStyle = "#0f0";
        ctx.font = "14px Courier";
        ctx.fillText("> INITIALIZING BIOMETRIC PROTOCOL...", 30, 100);
        if(bootTimer > 60) ctx.fillText("> HAND TRACKERS: ONLINE", 30, 130);
        if(bootTimer > 120) ctx.fillText("> OCULAR SCANNER: READY", 30, 160);
        if(bootTimer > 180) {
            ctx.fillStyle = "#ff0";
            ctx.fillText("BLINK TO START CALIBRATION", canvasElement.width/2 - 100, canvasElement.height/2);
            if(eyeClosed) {
                playSfx(400, 800, 0.2);
                gameState = "CALIBRATE";
            }
        }
    }

    else if (gameState === "CALIBRATE") {
        ctx.strokeStyle = "#0ff";
        ctx.strokeRect(50, canvasElement.height/2, canvasElement.width-100, 20);
        ctx.fillStyle = "#0ff";
        ctx.fillRect(52, canvasElement.height/2 + 2, romProgress * (canvasElement.width-104), 16);
        ctx.fillText("STRETCH FINGERS & PINCH TO CALIBRATE ROM", 30, canvasElement.height/2 - 30);

        if (pinching) romProgress += 0.01;
        if (romProgress >= 1) {
            playSfx(800, 1200, 0.3);
            gameState = "PLAYING";
        }
    }

    else if (gameState === "PLAYING") {
        const now = Date.now();

        // Shoot
        if (pinching && now - lastShotTime > 300) {
            bullets.push({x: handX, y: handY});
            lastShotTime = now;
            playSfx(600, 200, 0.1);
        }

        // Bullets
        bullets.forEach((b, i) => {
            b.y -= 15;
            ctx.fillStyle = "#0ff";
            ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill();
            if(b.y < 0) bullets.splice(i,1);
        });

        // Enemies
        if (Math.random() < 0.02 + (score/2000)) {
            enemies.push({ x: Math.random() * (canvasElement.width-40) + 20, y: -30, speed: 2 + (score/100), spawnTime: now });
        }

        enemies.forEach((e, i) => {
            e.y += e.speed;
            ctx.fillStyle = "#f33";
            ctx.beginPath(); ctx.arc(e.x, e.y, 20, 0, Math.PI*2); ctx.fill();

            // Hit detection
            bullets.forEach((b, bi) => {
                if(Math.hypot(e.x - b.x, e.y - b.y) < 25) {
                    enemies.splice(i, 1);
                    bullets.splice(bi, 1);
                    score += 10;
                    reactionTimes.push(Date.now() - e.spawnTime);
                    playSfx(150, 50, 0.2);
                }
            });

            if(e.y > canvasElement.height) {
                enemies.splice(i,1); lives--;
                if(lives <= 0) gameState = "GAMEOVER";
            }
        });

        // Reticle
        ctx.strokeStyle = pinching ? "#f00" : "#0f0";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(handX, handY, 25, 0, Math.PI*2);
        ctx.moveTo(handX - 35, handY); ctx.lineTo(handX + 35, handY);
        ctx.moveTo(handX, handY - 35); ctx.lineTo(handX, handY + 35);
        ctx.stroke();

        // UI
        ctx.fillStyle = "#0f0";
        ctx.fillText(`SCORE: ${score}`, 20, 50);
        ctx.fillStyle = "#f00";
        ctx.fillText(`LIVES: ${lives}`, canvasElement.width - 100, 50);
    }

    else if (gameState === "GAMEOVER") {
        ctx.fillStyle = "rgba(0,0,0,0.8)";
        ctx.fillRect(0,0, canvasElement.width, canvasElement.height);
        ctx.fillStyle = "#0f0";
        ctx.fillText("--- DIAGNOSTIC COMPLETE ---", 50, 100);

        const avgReaction = reactionTimes.length ? Math.round(reactionTimes.reduce((a,b)=>a+b)/reactionTimes.length) : 0;
        const stability = tremorData.length ? (10 - (tremorData.reduce((a,b)=>a+b)/tremorData.length)).toFixed(1) : 0;

        ctx.fillStyle = "#fff";
        ctx.fillText(`NEURO-STABILITY: ${stability}/10`, 50, 150);
        ctx.fillText(`AVG REACTION: ${avgReaction}ms`, 50, 180);
        ctx.fillText(`FINAL SCORE: ${score}`, 50, 210);

        ctx.fillStyle = "#ff0";
        ctx.fillText("TAP TO RE-BOOT", 50, 300);
    }

    requestAnimationFrame(drawLoop);
}

window.addEventListener('touchstart', () => {
    if(gameState === "GAMEOVER") location.reload();
    audioCtx.resume();
});

drawLoop();
</script>
</body>
</html>