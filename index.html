<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hand Shooter Mobile</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body { margin: 0; padding: 0; background-color: #000; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; transform: scaleX(-1); } /* Mirror Effect */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #score-board { position: absolute; top: 20px; left: 20px; color: white; font-size: 24px; font-weight: bold; }
        #lives-board { position: absolute; top: 20px; right: 20px; color: red; font-size: 24px; }
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: flex; flex-direction: column;
            justify-content: center; align-items: center; pointer-events: auto; z-index: 10;
        }
        button { padding: 15px 30px; font-size: 20px; background: #00ffcc; border: none; border-radius: 5px; cursor: pointer; }
        .hidden { display: none !important; }
        video { display: none; } /* Hide raw video feed */
    </style>
</head>
<body>

    <video id="input_video"></video>

    <canvas id="output_canvas"></canvas>

    <div id="ui-layer">
        <div id="score-board">Score: 0</div>
        <div id="lives-board">❤❤❤</div>
    </div>

    <div id="start-screen">
        <h1 style="color:white; text-align:center;">Hand Shooter<br>Mobile Edition</h1>
        <p style="color:#aaa;">Pinch to Shoot</p>
        <button onclick="startGame()">START GAME</button>
    </div>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const scoreBoard = document.getElementById('score-board');
    const livesBoard = document.getElementById('lives-board');
    const startScreen = document.getElementById('start-screen');

    let width, height;
    let score = 0;
    let lives = 3;
    let gameActive = false;
    let lastShotTime = 0;
    let difficultySpeed = 0;

    // Game Objects
    let bullets = [];
    let enemies = [];
    let particles = []; // Explosions
    let handX = 0, handY = 0;
    let isPinching = false;

    // Audio Context (Synthesizer)
    let audioCtx;

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvasElement.width = width;
        canvasElement.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- SOUND ENGINE (No files needed!) ---
    function initAudio() {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }

    function playSound(type) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        if (type === 'shoot') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(400, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        } else if (type === 'explosion') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.3);
            gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
        }
    }

    // --- GAME LOGIC ---
    function spawnEnemy() {
        const size = 30;
        const x = Math.random() * (width - 60) + 30;
        enemies.push({ x: x, y: -50, size: size, speed: 2 + Math.random() * 3 + difficultySpeed });
    }

    function createExplosion(x, y) {
        for (let i = 0; i < 8; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 1.0
            });
        }
    }

    function updateGame() {
        if (!gameActive) return;

        // Draw Background (Semi-transparent for trail effect)
        canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        canvasCtx.fillRect(0, 0, width, height);

        // 1. Handle Shooting
        if (isPinching && Date.now() - lastShotTime > 200) {
            bullets.push({ x: handX, y: handY });
            playSound('shoot');
            lastShotTime = Date.now();
        }

        // 2. Update Bullets
        canvasCtx.fillStyle = '#0f0';
        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i];
            b.y -= 15;
            canvasCtx.beginPath();
            canvasCtx.arc(b.x, b.y, 5, 0, Math.PI * 2);
            canvasCtx.fill();
            if (b.y < 0) bullets.splice(i, 1);
        }

        // 3. Update Enemies
        if (Math.random() < 0.02) spawnEnemy();

        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            e.y += e.speed;

            // Draw Enemy (Alien Face)
            canvasCtx.fillStyle = '#ff0000';
            canvasCtx.beginPath();
            canvasCtx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
            canvasCtx.fill();
            // Eyes
            canvasCtx.fillStyle = 'black';
            canvasCtx.beginPath(); canvasCtx.arc(e.x - 10, e.y - 5, 5, 0, Math.PI * 2); canvasCtx.fill();
            canvasCtx.beginPath(); canvasCtx.arc(e.x + 10, e.y - 5, 5, 0, Math.PI * 2); canvasCtx.fill();

            // Collision: Enemy vs Bullet
            let hit = false;
            for (let j = bullets.length - 1; j >= 0; j--) {
                let b = bullets[j];
                let dist = Math.hypot(e.x - b.x, e.y - b.y);
                if (dist < e.size + 5) {
                    bullets.splice(j, 1);
                    hit = true;
                    break;
                }
            }

            if (hit) {
                createExplosion(e.x, e.y);
                playSound('explosion');
                score += 10;
                scoreBoard.innerText = "Score: " + score;
                if (score % 100 === 0) difficultySpeed += 1;
                enemies.splice(i, 1);
                continue;
            }

            // Game Over Check
            if (e.y > height) {
                lives--;
                livesBoard.innerText = "❤".repeat(lives);
                enemies.splice(i, 1);
                if (lives <= 0) gameOver();
            }
        }

        // 4. Update Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.05;
            canvasCtx.fillStyle = `rgba(255, 165, 0, ${p.life})`;
            canvasCtx.beginPath();
            canvasCtx.arc(p.x, p.y, 3, 0, Math.PI * 2);
            canvasCtx.fill();
            if (p.life <= 0) particles.splice(i, 1);
        }

        // 5. Draw Hand Cursor
        const cursorColor = isPinching ? '#ff0000' : '#00ffff';
        canvasCtx.strokeStyle = cursorColor;
        canvasCtx.lineWidth = 3;
        canvasCtx.beginPath();
        canvasCtx.arc(handX, handY, 20, 0, Math.PI * 2);
        canvasCtx.stroke();

        // Crosshair
        canvasCtx.beginPath();
        canvasCtx.moveTo(handX - 30, handY); canvasCtx.lineTo(handX + 30, handY);
        canvasCtx.moveTo(handX, handY - 30); canvasCtx.lineTo(handX, handY + 30);
        canvasCtx.stroke();
    }

    function gameOver() {
        gameActive = false;
        startScreen.classList.remove('hidden');
        document.querySelector('h1').innerText = "GAME OVER";
        document.querySelector('button').innerText = "RESTART";
    }

    function startGame() {
        initAudio();
        startScreen.classList.add('hidden');
        score = 0;
        lives = 3;
        difficultySpeed = 0;
        enemies = [];
        bullets = [];
        scoreBoard.innerText = "Score: 0";
        livesBoard.innerText = "❤❤❤";
        gameActive = true;
    }

    // --- MEDIAPIPE SETUP ---
    function onResults(results) {
        // Draw the raw camera feed? No, we draw a black game bg.
        // We only need coordinates.
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];

            // Get Index Tip (8)
            const indexTip = landmarks[8];
            const thumbTip = landmarks[4];

            // Map coordinates to canvas size
            // Note: MediaPipe x is 0-1. We flip X because of the mirror effect CSS.
            handX = (1 - indexTip.x) * width;
            handY = indexTip.y * height;

            // Pinch Detection
            const distance = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
            isPinching = distance < 0.05;
        }

        requestAnimationFrame(updateGame);
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 1280,
        height: 720
    });

    // Auto-start camera
    camera.start();

</script>
</body>
</html>